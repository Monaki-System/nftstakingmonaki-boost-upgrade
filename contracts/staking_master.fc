#include "imports/stdlib.fc";
#include "constants.fc";

global cell data::items;
global slice data::jetton_master;
global cell data::jetton_wallet_code;
global cell data::helper_code;

global int context::op;
global int context::query_id;
global slice context::sender;

() load_data() impure {
    slice ds = get_data().begin_parse();
    data::items = ds~load_dict();
    data::jetton_master = ds~load_msg_addr();
    data::jetton_wallet_code = ds~load_ref();
    data::helper_code = ds~load_ref();
}

() save_data() impure {
    set_data(begin_cell()
        .store_dict(data::items)
        .store_slice(data::jetton_master)
        .store_ref(data::jetton_wallet_code)
        .store_ref(data::helper_code)
    .end_cell());
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_bits() < 96) {
        return ();
    }

    context::op = in_msg_body~load_uint(32);
    context::query_id = in_msg_body~load_uint(64);
    (_, context::sender) = in_msg_full.begin_parse().skip_bits(4).load_msg_addr();

    load_data();

    if (context::op == op::nft::ownership_assigned) {
        slice prev_owner = in_msg_body~load_msg_addr();
        slice forward_payload = in_msg_body;
        if (forward_payload~load_int(1)) {
            forward_payload = forward_payload~load_ref().begin_parse();
        }

        int op = forward_payload~load_uint(32);
        if (op == op::stake) {
            int option = forward_payload~load_uint(2);

            cell stateinit = begin_cell()
                .store_uint(0, 2)
                .store_ref(data::helper_code)
                .store_ref(begin_cell()
                    .store_slice(my_address())
                    .store_slice(context::sender)
                    .store_uint(0, 68)
                .end_cell())
                .store_uint(0, 1)
            .end_cell();
            slice address = begin_cell()
                .store_uint(4, 3)
                .store_int(0, 8)
                .store_uint(cell_hash(stateinit), 256)
            .end_cell().begin_parse();

            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(address)
                .store_coins(0)
                .store_uint(6, 108)
                .store_ref(stateinit)
                .store_uint(op::process_stake, 32)
                .store_uint(context::query_id, 64)
                .store_slice(prev_owner)
                .store_uint(option, 2)
            .end_cell(), 64);
        } else {
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(context::sender)
                .store_coins(0)
                .store_uint(0, 107)
                .store_uint(op::nft::transfer, 32)
                .store_uint(context::query_id, 64)
                .store_slice(prev_owner)
                .store_uint(0, 8)
            .end_cell(), 64);
        }
    }

    elseif (context::op == op::request_claim) {
        slice staker = in_msg_body~load_msg_addr();
        int option = in_msg_body~load_uint(2);

        cell stateinit = begin_cell()
            .store_uint(0, 2)
            .store_ref(data::helper_code)
            .store_ref(begin_cell()
                .store_slice(my_address())
                .store_slice(item)
                .store_uint(0, 68)
            .end_cell())
            .store_uint(0, 1)
        .end_cell();
        slice address = begin_cell()
            .store_uint(4, 3)
            .store_int(0, 8)
            .store_uint(cell_hash(stateinit), 256)
        .end_cell().begin_parse();

        throw_unless(error::wrong_sender, equal_slices(context::sender, address));

        slice jetton_wallet_address = calculate_user_jetton_wallet_address(my_address(), data::jetton_master, data::jetton_wallet_code);

        int amount = (option == 0) ? 1000000000 : ((option == 1) ? 2000000000 : 3000000000);

        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_wallet_address)
            .store_coins(0)
            .store_uint(0, 107)
            .store_uint(op::jetton::transfer, 32)
            .store_uint(context::query_id, 64)
            .store_coins(amount)
            .store_slice(staker)
            .store_uint(0, 8)
        .end_cell(), 64);
    }

    else {
        throw(0xffff);
    }

    save_data();
}
